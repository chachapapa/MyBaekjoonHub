function solution(n, tops) {
    var answer = 0;
    //dp로 푸는거래
    // n = 1 일때
    //
    
    const MOD = 10007;
    //2차원배열인 이유는
    //[n][0]은 마지막이 세모로 끝나는 경우, [n][1] 마지막이 마름모로 끝나는 경우
    const dp = new Array(n + 1).fill().map(() => new Array(2).fill(0));
    
    //윗변 길이가 0일때
    //즉 삼각형 하나
    dp[0][0] = 1;
    
    //윗변 길이가 1이고 탑이 없을때
    //삼각형세개 -> 위 경우에서 + 2세모
    //마름모-세모 -> 왼쪽 + 마름모 
    //세모-마름모 -> 오른쪽 + 마름모
    
    
    //윗변 길이가 2고 탑이 없을때
    //각 경우에서 오른쪽 마름모 추가한거
    //각 경우에서 오른쪽 세모 두개추가한거
    //오른쪽 하나 없애고 마름모+세모 추가한거
    

    for (let i = 0; i < n; i += 1) {
        //탑 있을때
        if (tops[i]) {
            //끝을 삼각형으로 끝내고 싶은 경우
            //i 의 경우에 삼각형으로 끝나면, 세가지
            //i 의 경우에 마름모로 끝나면, 두가지
            dp[i + 1][0] = dp[i][0] * 3 + dp[i][1] * 2;
        //없을때는    
        } else {
            // 끝을 삼각형으로 끝내고 싶을 때
            // i 의 경우에서 끝이 삼각형으로 끝나면 이후에 삼각형두개 붙이거나, 삼각형 하나 떼고 반대마름모+삼각형
            // i 의 경우에서 끝이 마름모로 끝날때는 삼각형 하나떼고 반대마름모를 붙일 수가 없어서 삼각형 두개붙이는 경우밖에 없음
            dp[i+1][0] = dp[i][0]*2+dp[i][1]
        }

        dp[i + 1][1] = dp[i][0] + dp[i][1];

        dp[i + 1][0] %= MOD;
        dp[i + 1][1] %= MOD;
    }

    return (dp[n][0] + dp[n][1]) % MOD;
    
    
    return answer;
}